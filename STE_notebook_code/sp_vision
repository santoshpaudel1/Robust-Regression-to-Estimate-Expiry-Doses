from skimage.measure import label
import numpy as np

def getConnectedComponents(segmentation):
    """
    Get all connected components in the segmentation, sorted by size.
    
    Parameters:
    segmentation (numpy.ndarray): Segmentation image.
    
    Returns:
    dict: Dictionary of connected components sorted by size.
    """
    labels = label(segmentation)
    component_sizes = np.bincount(labels.ravel())
    sorted_components = np.argsort(component_sizes)[::-1]  # Sort components from largest to smallest
    sorted_components = sorted_components[sorted_components != 0]  # Exclude background label (0)
    
    connected_components = {}
    for i, component in enumerate(sorted_components):
        mask = labels == component
        if np.any(mask):
            connected_components[i] = mask
    return connected_components


from skimage.measure import label, regionprops
import numpy as np

def getConnectedComponents(segmentation):
    """
    Get connected components sorted by size using memory-efficient storage.
    
    Parameters:
    segmentation (numpy.ndarray): Input segmentation image
    
    Returns:
    list: Sorted components as (bbox, mask_image) tuples
    """
    # Label with smaller dtype to reduce memory
    labels = label(segmentation, dtype=np.uint16)
    
    # Get region properties and immediately process them
    regions = regionprops(labels)
    
    # Extract components with sorting information
    components = [
        (r.bbox, r.image, r.area)
        for r in regions
    ]
    
    # Free memory from large arrays
    del labels, regions
    
    # Sort by component size (descending)
    components.sort(key=lambda x: x[2], reverse=True)
    
    # Return compact representation (bbox and sub-mask)
    return [(comp[0], comp[1]) for comp in components]

###########usage##############################
components = getConnectedComponents(your_segmentation)

for bbox, mask_image in components:
    min_row, min_col, max_row, max_col = bbox
    full_mask = np.zeros_like(your_segmentation, dtype=bool)
    full_mask[min_row:max_row, min_col:max_col] = mask_image
    # Use full_mask for processing

################################# This might be better in term of processing #############################

from skimage.measure import label
import numpy as np

def getConnectedComponents(segmentation):
    """
    Get connected components metadata for lazy loading, sorted by size.
    
    Returns:
    tuple: (labels_array, sorted_component_labels)
    """
    labels = label(segmentation)
    component_sizes = np.bincount(labels.ravel())
    sorted_components = np.argsort(component_sizes)[::-1]
    sorted_components = sorted_components[sorted_components != 0]  # Remove background
    
    return labels, sorted_components


# Get component metadata
labels, sorted_labels = getConnectedComponents(segmentation)

# Get total component count
num_components = len(sorted_labels)

# Process components in sorted order
for i, component_id in enumerate(sorted_labels):
    # Generate mask on demand
    mask = labels == component_id
    # Process single component
    process_component(mask)
    
    # Optional: Clear memory if processing many components
    del mask
